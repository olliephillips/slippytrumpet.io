<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>slippytrumpet.io</title>
    <link>https://slippytrumpet.io/categories/programming/index.xml</link>
    <description>Recent content on slippytrumpet.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://slippytrumpet.io/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Sett, a BadgerDB abstraction</title>
      <link>https://slippytrumpet.io/posts/sett-a-badgerdb-abstraction/</link>
      <pubDate>Fri, 04 May 2018 10:08:30 +0100</pubDate>
      
      <guid>https://slippytrumpet.io/posts/sett-a-badgerdb-abstraction/</guid>
      <description>

&lt;h2 id=&#34;a-little-go-package-to-make-badgerdb-easier-for-me-to-work-with&#34;&gt;A little Go package to make BadgerDB easier (for me) to work with&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve noticed that as an &amp;ldquo;older&amp;rdquo; developer, often, one of the first things I&amp;rsquo;ll do with a new package/API I&amp;rsquo;m using, is abstract it into just the bits I need and/or that my cognitive resources can cope with.&lt;/p&gt;

&lt;p&gt;The end result is often something akin to plain english (in terms of code), and while I&amp;rsquo;m not sure this says much for my cognition and memory, I do often wonder why this is not better syntax full stop?&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example. This package, named &lt;a href=&#34;https://github.com/olliephillips/sett&#34;&gt;Sett&lt;/a&gt;, abstracts the &lt;a href=&#34;https://github.com/dgraph-io/badger&#34;&gt;BadgerDB&lt;/a&gt; API, the focus simply on easy reuse of the BadgerDB methods that I&amp;rsquo;m likely to want to use most frequently.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not suggesting there&amp;rsquo;s anything wrong with the BadgerDB API, only that, for me, the syntax seems quite complex and is therefore not easy to recall. Hence me writing Sett which literally just hides the complicated code enabling me to be more productive with BadgerDB.&lt;/p&gt;

&lt;p&gt;To give one example, below we retrieve the value of a single key  from the data store and print it. First with the BadgerDB method, and then with Sett.&lt;/p&gt;

&lt;h3 id=&#34;get-with-badgerdb&#34;&gt;Get with BadgerDB&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// BadgerDB
var answer []byte
err := db.View(func(txn *badger.Txn) error {
  item, err := txn.Get([]byte(&amp;quot;question&amp;quot;))
  if err != nil {
    return err
  }
  answer, err := item.Value()
  if err != nil {
    return err
  }
  return nil
})
if err != nil {
	log.Fatal(err)
}
fmt.Printf(&amp;quot;The answer is: %s\n&amp;quot;, answer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;get-with-sett&#34;&gt;Get with Sett&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// Sett
answer, err := db.Get(&amp;quot;question&amp;quot;)
if err != nil {
	log.Fatal(err)
}
fmt.Printf(&amp;quot;The answer is: %s\n&amp;quot;, answer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Which version can you remember?&lt;/p&gt;

&lt;p&gt;I should however point out that in BadgerDB, &lt;code&gt;db.View&lt;/code&gt; is a read transaction wrapper.  So, while the above examples both include a single &lt;code&gt;Get&lt;/code&gt; transaction, BadgerDB could accomodate more.&lt;/p&gt;

&lt;p&gt;We could for example retrieve a second key in the same transaction, which would doubtless be more efficient than the two sequential &lt;code&gt;db.View&lt;/code&gt; transactions, required to get two keys when using Sett.&lt;/p&gt;

&lt;p&gt;But, realistically, how often will I want more than one key, selected by specific key? Should I find the need, a small modification to the Sett API could facilitate the return of multples keys in the one &lt;code&gt;GET&lt;/code&gt; call.&lt;/p&gt;

&lt;h2 id=&#34;virtual-tables&#34;&gt;&amp;ldquo;Virtual&amp;rdquo; tables&lt;/h2&gt;

&lt;p&gt;One feature of the Sett API that I find indispensible, is virtual tables.&lt;/p&gt;

&lt;p&gt;Tables are effectively created by adding a prefix to the key which is stored in BadgerDB, hence virtual, since tables are not a feature of BadgerDB.&lt;/p&gt;

&lt;p&gt;With an interface formalised through the Sett API, I&amp;rsquo;ve found it much easier to reason about the data I&amp;rsquo;m working with, by thinking in terms of tables.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example which shows how the use of these virtual tables allows key reuse.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s.Table(&amp;quot;client&amp;quot;).Set(&amp;quot;1234&amp;quot;, &amp;quot;client data&amp;quot;)
// real key is &amp;quot;client1234&amp;quot;
s.Table(&amp;quot;client&amp;quot;).Get(&amp;quot;1234&amp;quot;)
// returns &amp;quot;client data&amp;quot;

s.Table(&amp;quot;supplier&amp;quot;).Set(&amp;quot;1234&amp;quot;, &amp;quot;supplier data&amp;quot;)
// real key is &amp;quot;supplier1234&amp;quot;
s.Table(&amp;quot;supplier&amp;quot;).Get(&amp;quot;1234&amp;quot;)
// returns &amp;quot;supplier data&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Tables also allow us to implement other nice features such as &lt;code&gt;Drop()&lt;/code&gt; which, as you might expect, deletes the virtual table or more accurately, all keys with the table prefix.&lt;/p&gt;

&lt;h2 id=&#34;updates&#34;&gt;Updates&lt;/h2&gt;

&lt;p&gt;BadgerDB also includes a &lt;code&gt;db.Update&lt;/code&gt; transaction wrapper designed to wrap &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Delete&lt;/code&gt; transactions, and it&amp;rsquo;s possible to write or delete multiple items by key.&lt;/p&gt;

&lt;p&gt;This is definitely something I want to do efficiently via Sett, so I implemented batch updates - and the API is not dissimilar to the functionality that used to exist in BadgerDB itself!&lt;/p&gt;

&lt;p&gt;Items are added to the dataset to be stored using &lt;code&gt;Batchcup()&lt;/code&gt;`.&lt;/p&gt;

&lt;p&gt;Large datasets are split into smaller batches of 500 (by default) and each batch of 500 is passed to a goroutine tasked with inserting those 500 keys. We can achieve very high write speed using concurrency and goroutines, though optimum batchsize will depend on size of the dataset and the performance of your hardware.&lt;/p&gt;

&lt;p&gt;Sett splits the dataset into batches for you, in the background, no need to write your own goroutines.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a very simple example which creates a batch of three keys/values, before submitting the batch to BadgerDB for insertion to the &amp;ldquo;client&amp;rdquo; table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s.Batchup(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;)
s.Batchup(&amp;quot;hello-again&amp;quot;, &amp;quot;world&amp;quot;)
s.Batchup(&amp;quot;goodbye&amp;quot;, &amp;quot;world&amp;quot;)

s.Table(&amp;quot;client&amp;quot;).SetBatch()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
There&amp;rsquo;s more to Sett, and the README on Github covers it.&lt;/p&gt;

&lt;p&gt;And there&amp;rsquo;s room to improve it. One area of concern is reporting and returning from goroutines which error, and this is something I&amp;rsquo;ll be looking into.&lt;/p&gt;

&lt;p&gt;If you find Sett useful, let me know in the comments. If I&amp;rsquo;ve made any errors please also let me know. I&amp;rsquo;m always learning.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Experiments with Messaging over Ethernet Frames</title>
      <link>https://slippytrumpet.io/posts/experiments-with-message-queuing-over-ethernet-frames/</link>
      <pubDate>Mon, 10 Jul 2017 17:27:33 +0100</pubDate>
      
      <guid>https://slippytrumpet.io/posts/experiments-with-message-queuing-over-ethernet-frames/</guid>
      <description>

&lt;h2 id=&#34;in-his-article-network-protocol-breakdown-ethernet-and-go-https-medium-com-mdlayher-network-protocol-breakdown-ethernet-and-go-de985d726cc1-matt-layher-describes-the-ethernet-protocol-and-introduces-a-couple-of-libraries-written-in-go&#34;&gt;In his article, &lt;a href=&#34;https://medium.com/@mdlayher/network-protocol-breakdown-ethernet-and-go-de985d726cc1&#34;&gt;Network Protocol Breakdown: Ethernet and Go&lt;/a&gt;, Matt Layher describes the Ethernet protocol and introduces a couple of libraries written in Go.&lt;/h2&gt;

&lt;p&gt;I read the article with interest. Application communication, at the Ethernet frame level, a lower level than TCP sockets, was something I&amp;rsquo;d never considered before.&lt;/p&gt;

&lt;p&gt;Of particular interest was the &amp;ldquo;broadcast&amp;rdquo; nature of the communication. In contrast to sockets - though frames can also be addressed to specific devices - frames can be broadcast network-wide, enabling more than one device to listen and use the frame payload.&lt;/p&gt;

&lt;p&gt;I could see some parallels between Ethernet frames and MQTT, a protocol I use frequently in my hardware projects.&lt;/p&gt;

&lt;p&gt;I could also see a few distinct advantages over MQTT. I don&amp;rsquo;t want to go into loads of detail here, but, suffice to say, a cheap, convenient but very insecure approach to using MQTT in what are often just &amp;ldquo;hobby&amp;rdquo; hardware projects, is to bounce traffic off of one of the free remote MQTT brokers. And I have been known to do this ;)&lt;/p&gt;

&lt;h2 id=&#34;so-why-ethernet-frames&#34;&gt;So why Ethernet Frames?&lt;/h2&gt;

&lt;p&gt;Potentially, by using Ethernet frames there would be no requirement for the MQTT broker so that&amp;rsquo;s one less piece of hardware to configure and manage (if you host your own); messages would stay within the local area network, behind the router firewall, so we&amp;rsquo;re secure by default and; we might achieve higher-speed transmissions, since we would not be sending data all the way off to a remote MQTT broker, only to receive it back from that broker on another machine sitting within the same local area network.&lt;/p&gt;

&lt;p&gt;So I set about writing a package on top of Matt&amp;rsquo;s &lt;a href=&#34;https://github.com/mdlayher/ethernet&#34;&gt;Ethernet&lt;/a&gt; and &lt;a href=&#34;https://github.com/mdlayher/raw&#34;&gt;Raw&lt;/a&gt; packages with two objectives in mind:-&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use Ethernet frame messaging to emulate MQTT specifically by providing pub/sub functionality, and;&lt;/li&gt;
&lt;li&gt;Provide an API which would feel familiar to MQTT users and therefore be a relatively simple drop in replacement for a typical MQTT client library.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;methodology&#34;&gt;Methodology&lt;/h2&gt;

&lt;p&gt;The package itself is fairly straightforward - most of the sophisticated stuff is performed by the two packages of Matt&amp;rsquo;s which it imports, but it satisfies both of the objectives mentioned above.&lt;/p&gt;

&lt;p&gt;I took the liberty of naming the package EFMQ (for Ethernet Frames Message Queue), and you can find it &lt;a href=&#34;http://github.com/olliephillips/efmq&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;objective-1-provide-pub-sub-functionality&#34;&gt;Objective 1 - Provide Pub/Sub functionality&lt;/h3&gt;

&lt;p&gt;Pub/Sub is emulated by devices maintaining a list of their own subscriptions and comparing each received message&amp;rsquo;s topic to this list. If topic matches a subscription, the message is put on an unbuffered channel for subsequent processing. Any messages that do not match a subscription are simply discarded.&lt;/p&gt;

&lt;h3 id=&#34;objective-2-provide-an-api-similar-to-mqtt&#34;&gt;Objective 2 - Provide an API similar to MQTT&lt;/h3&gt;

&lt;p&gt;This is best illustrated by a couple of examples.&lt;/p&gt;

&lt;h4 id=&#34;publisher&#34;&gt;Publisher&lt;/h4&gt;

&lt;p&gt;In this contrived example, we&amp;rsquo;re publishing temperature data on the &lt;code&gt;temp&lt;/code&gt; topic every second. &lt;code&gt;wlan0&lt;/code&gt; represents the network interface used by the device, in this case a Raspberry Pi Zero W.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mq, err := efmq.NewEFMQ(&amp;quot;wlan0&amp;quot;) 
if err != nil {
  log.Fatal(err)
}
t := time.NewTicker(1 * time.Second)
for range t.C {
  if err := mq.Publish(&amp;quot;temp&amp;quot;, &amp;quot;20.5&amp;quot;); err != nil {
 	log.Fatalln(err)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h4 id=&#34;subscriber&#34;&gt;Subscriber&lt;/h4&gt;

&lt;p&gt;In this example another device in the same network subscribes to the &lt;code&gt;temp&lt;/code&gt; topic and then listens indefinitely. Any messages which match the subscription are made available on the &lt;code&gt;mq.Message&lt;/code&gt; channel.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mq, err := efmq.NewEFMQ(&amp;quot;wlan0&amp;quot;)
if err != nil {
  log.Fatal(err)
}
mq.Subscribe(&amp;quot;fermenter&amp;quot;)
mq.Listen()
for msg := range mq.Message {
  fmt.Println(&amp;quot;topic:&amp;quot;, msg.Topic)
  fmt.Println(&amp;quot;message:&amp;quot;, msg.Payload)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;performance&#34;&gt;Performance&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re off to a good start by removing the latency transmitting messages via a remote server, and the messaging is direct between two devices, no third device (a local MQTT broker) is needed to relay messages, but as yet I don&amp;rsquo;t have any benchmarks.&lt;/p&gt;

&lt;p&gt;In testing, I&amp;rsquo;ve been running a dummy setup using two Raspberry Pi Zero W devices which have been communicating using EFMQ at an interval of 50ms for over a week with no issues. 50ms means 20 messages per second - more than sufficient for most monitoring and control applications that I&amp;rsquo;m likely to want to build!&lt;/p&gt;

&lt;p&gt;If you give EFMQ a try please let me know how it works for you!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Let&#39;s Encrypt and Go</title>
      <link>https://slippytrumpet.io/posts/letsencrypt-and-go/</link>
      <pubDate>Mon, 31 Oct 2016 18:43:50 +0100</pubDate>
      
      <guid>https://slippytrumpet.io/posts/letsencrypt-and-go/</guid>
      <description>

&lt;h2 id=&#34;recently-i-implemented-tls-using-let-s-encrypt-for-two-go-applications-i-thought-i-d-outline-the-process-i-followed-and-mention-a-couple-of-issues-i-had&#34;&gt;Recently I implemented TLS using Let&amp;rsquo;s Encrypt for two Go applications. I thought I&amp;rsquo;d outline the process I followed and mention a couple of issues I had.&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://letsencrypt.org/&#34;&gt;Let&amp;rsquo;s Encrypt&lt;/a&gt; is a fabulous service. In making TLS freely accessible to the masses it&amp;rsquo;s helping make the Internet a more secure place.&lt;/p&gt;

&lt;p&gt;For Go applications, there&amp;rsquo;s no automatic install and renewal route, the process you follow to obtain a certificate takes you via the &amp;ldquo;&lt;a href=&#34;http://letsencrypt.readthedocs.io/en/latest/using.html#standalone&#34;&gt;standalone&lt;/a&gt;&amp;rdquo; option.&lt;/p&gt;

&lt;p&gt;Alternatively, you can use a helper package such as &lt;a href=&#34;https://github.com/dkumor/acmewrapper&#34;&gt;ACMEWrapper&lt;/a&gt; in your application; add a bit of code and ACMEWrapper automatically handles certificate creation and more importantly renewal, since Let&amp;rsquo;s Encrypt certificates expire every 90 days.&lt;/p&gt;

&lt;p&gt;I didn&amp;rsquo;t use ACMEWrapper. In fact I only learned of this package after my TLS deployments were done. But even without one of these helper packages, the process of certificate creation and renewal via the &amp;ldquo;standalone&amp;rdquo; route is straightforwards:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Install the Let&amp;rsquo;s Encrypt client &amp;ldquo;Certbot&amp;rdquo; on your server;&lt;/li&gt;
&lt;li&gt;Run a single command to generate the certificates for the required domain;&lt;/li&gt;
&lt;li&gt;Either copy, or symlink, the required key and certificate files to your application.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;unbind-all-your-things&#34;&gt;Unbind all your things&lt;/h2&gt;

&lt;p&gt;To create a certificate for a domain, Let&amp;rsquo;s Encrypt needs to validate you control the domain.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re generating the certificates on the server on you which you want to use them, this requires that port 80 and/or 443 are available to Certbot. This means you&amp;rsquo;ll have to unbind anything running on those ports, which typically means you&amp;rsquo;ll have to stop your application(s) for the duration of the certificate creation process.&lt;/p&gt;

&lt;p&gt;Certbot makes you aware if it can&amp;rsquo;t use the ports it needs, so this is a minor obstacle and quickly overcome. I only mention it in case your application already has users - you&amp;rsquo;ll want to consider when best to run Certbot.&lt;/p&gt;

&lt;p&gt;No big deal but my first issue - my application was already live, and had to go offline for about 20 seconds to free those ports for Certbot.&lt;/p&gt;

&lt;h2 id=&#34;i-think-your-ssl-has-expired&#34;&gt;I think your SSL has expired?&lt;/h2&gt;

&lt;p&gt;Certbot &amp;ldquo;standalone&amp;rdquo; creates four files after successfully completing.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cert.pem
chain.pem
fullchain.pem
privkey.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Your go application needs two - but which two?&lt;/p&gt;

&lt;p&gt;You need a private key, so &lt;code&gt;privkey.pem&lt;/code&gt; is an obvious pick. You also need the certificate itself, so &lt;code&gt;cert.pem&lt;/code&gt; is a reasonable choice too.&lt;/p&gt;

&lt;p&gt;But you need to use the less obviously named &lt;code&gt;fullchain.pem&lt;/code&gt; for the certificate in your Go application. This file combines server, root and intermediate certificates into one.&lt;/p&gt;

&lt;p&gt;Choose the more obvious &lt;code&gt;cert.pem&lt;/code&gt; (as I did) and though the certificate may look good to you and many others, you&amp;rsquo;ll get reports from people using some browsers saying your SSL has expired or your TLS is broken, and they can&amp;rsquo;t or won&amp;rsquo;t use your site.&lt;/p&gt;

&lt;p&gt;Hard to debug.&lt;/p&gt;

&lt;p&gt;So why &lt;code&gt;fullchain.pem&lt;/code&gt;? Though my knowledge is limited, broadly it seems to relate to the fact that Let&amp;rsquo;s Encrypt certificates are currently cross signed by Identrust to ensure browser acceptance. Let&amp;rsquo;s Encrypt is not as yet a root authority so needs this, especially to appear trusted in older browsers.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>