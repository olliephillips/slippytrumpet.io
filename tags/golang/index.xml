<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on slippytrumpet.io</title><link>https://slippytrumpet.io/tags/golang/</link><description>Recent content in golang on slippytrumpet.io</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 04 May 2018 10:08:30 +0100</lastBuildDate><atom:link href="https://slippytrumpet.io/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Sett, a BadgerDB abstraction</title><link>https://slippytrumpet.io/posts/sett-a-badgerdb-abstraction/</link><pubDate>Fri, 04 May 2018 10:08:30 +0100</pubDate><guid>https://slippytrumpet.io/posts/sett-a-badgerdb-abstraction/</guid><description>A little Go package to make BadgerDB easier (for me) to work with I&amp;rsquo;ve noticed that as an &amp;ldquo;older&amp;rdquo; developer, often, one of the first things I&amp;rsquo;ll do with a new package/API I&amp;rsquo;m using, is abstract it into just the bits I need and/or that my cognitive resources can cope with.
The end result is often something akin to plain english (in terms of code), and while I&amp;rsquo;m not sure this says much for my cognition and memory, I do often wonder why this is not better syntax full stop?</description></item><item><title>Octogon G-Code File Uploader</title><link>https://slippytrumpet.io/posts/octogon-gcode-file-uploader/</link><pubDate>Tue, 05 Dec 2017 23:05:39 +0000</pubDate><guid>https://slippytrumpet.io/posts/octogon-gcode-file-uploader/</guid><description>An automatic file upload utility for OctoPrint Octogon is a simple command line utility which will monitor a single folder on your local file system for the addition/modification of .stl and .gcode extension files and automatically copy them to OctoPrint so they appear in your files list.
Why? My 3D Printer is right next to me at the moment. But getting files onto it, configuring it, and monitoring it, are jobs that are a bit painful in this wireless age.</description></item><item><title>Experiments with Messaging over Ethernet Frames</title><link>https://slippytrumpet.io/posts/experiments-with-message-queuing-over-ethernet-frames/</link><pubDate>Mon, 10 Jul 2017 17:27:33 +0100</pubDate><guid>https://slippytrumpet.io/posts/experiments-with-message-queuing-over-ethernet-frames/</guid><description>In his article, Network Protocol Breakdown: Ethernet and Go, Matt Layher describes the Ethernet protocol and introduces a couple of libraries written in Go. I read the article with interest. Application communication, at the Ethernet frame level, a lower level than TCP sockets, was something I&amp;rsquo;d never considered before.
Of particular interest was the &amp;ldquo;broadcast&amp;rdquo; nature of the communication. In contrast to sockets - though frames can also be addressed to specific devices - frames can be broadcast network-wide, enabling more than one device to listen and use the frame payload.</description></item><item><title>Running your Application as a Service on Pi Zero W</title><link>https://slippytrumpet.io/posts/running-your-app-as-service-on-pi-zero-w/</link><pubDate>Thu, 08 Jun 2017 10:27:15 +0100</pubDate><guid>https://slippytrumpet.io/posts/running-your-app-as-service-on-pi-zero-w/</guid><description>Daemonize your application so that it is easily started, stopped and resilient to crashes So you&amp;rsquo;ve got your headless Raspberry Pi Zero W all set up and you&amp;rsquo;ve been running applications you&amp;rsquo;ve written for yourself on it? I have, I&amp;rsquo;m using Go with a combination of Embd and Periph.io libraries to interact with the hardware on the Pi Zero W itself and external to it.
But it feels clunky.</description></item><item><title>Raspberry Pi Zero W &#34;headless&#34; Setup</title><link>https://slippytrumpet.io/posts/raspberry-pi-zero-w-setup/</link><pubDate>Fri, 17 Mar 2017 16:06:50 +0000</pubDate><guid>https://slippytrumpet.io/posts/raspberry-pi-zero-w-setup/</guid><description>Pictured: My Raspberry Pi Zero W stand/rack. Get it on Thingiverse
An end-to-end log of the set-up process I followed from my Macbook What&amp;rsquo;s this all about? Setting up a Raspberry Pi Zero W in a &amp;ldquo;headless&amp;rdquo; configuration, without a keyboard or monitor; Configuring access to multiple Wifi access points; Securing via passwordless SSH public key only login and Firewall rules configuration; Simple command line Terminal access by configuring Hostname/Hosts; Creating a custom image, which we can reuse next time we want to configure another Pi Zero W.</description></item><item><title>Let&#39;s Encrypt and Go</title><link>https://slippytrumpet.io/posts/letsencrypt-and-go/</link><pubDate>Mon, 31 Oct 2016 18:43:50 +0100</pubDate><guid>https://slippytrumpet.io/posts/letsencrypt-and-go/</guid><description>Recently I implemented TLS using Let&amp;rsquo;s Encrypt for two Go applications. I thought I&amp;rsquo;d outline the process I followed and mention a couple of issues I had. Let&amp;rsquo;s Encrypt is a fabulous service. In making TLS freely accessible to the masses it&amp;rsquo;s helping make the Internet a more secure place.
For Go applications, there&amp;rsquo;s no automatic install and renewal route, the process you follow to obtain a certificate takes you via the &amp;ldquo;standalone&amp;rdquo; option.</description></item></channel></rss>