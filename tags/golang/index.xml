<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>slippytrumpet.io</title>
    <link>https://slippytrumpet.io/tags/golang/index.xml</link>
    <description>Recent content on slippytrumpet.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://slippytrumpet.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Sett, a BadgerDB abstraction</title>
      <link>https://slippytrumpet.io/posts/sett-a-badgerdb-abstraction/</link>
      <pubDate>Fri, 04 May 2018 10:08:30 +0100</pubDate>
      
      <guid>https://slippytrumpet.io/posts/sett-a-badgerdb-abstraction/</guid>
      <description>

&lt;h2 id=&#34;a-little-go-package-to-make-badgerdb-easier-for-me-to-work-with&#34;&gt;A little Go package to make BadgerDB easier (for me) to work with&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve noticed that as an &amp;ldquo;older&amp;rdquo; developer, often, one of the first things I&amp;rsquo;ll do with a new package/API I&amp;rsquo;m using, is abstract it into just the bits I need and/or that my cognitive resources can cope with.&lt;/p&gt;

&lt;p&gt;The end result is often something akin to plain english (in terms of code), and while I&amp;rsquo;m not sure this says much for my cognition and memory, I do often wonder why this is not better syntax full stop?&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example. This package, named &lt;a href=&#34;https://github.com/olliephillips/sett&#34;&gt;Sett&lt;/a&gt;, abstracts the &lt;a href=&#34;https://github.com/dgraph-io/badger&#34;&gt;BadgerDB&lt;/a&gt; API, the focus simply on easy reuse of the BadgerDB methods that I&amp;rsquo;m likely to want to use most frequently.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not suggesting there&amp;rsquo;s anything wrong with the BadgerDB API, only that, for me, the syntax seems quite complex and is therefore not easy to recall. Hence me writing Sett which literally just hides the complicated code enabling me to be more productive with BadgerDB.&lt;/p&gt;

&lt;p&gt;To give one example, below we retrieve the value of a single key  from the data store and print it. First with the BadgerDB method, and then with Sett.&lt;/p&gt;

&lt;h3 id=&#34;get-with-badgerdb&#34;&gt;Get with BadgerDB&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// BadgerDB
var answer []byte
err := db.View(func(txn *badger.Txn) error {
  item, err := txn.Get([]byte(&amp;quot;question&amp;quot;))
  if err != nil {
    return err
  }
  answer, err := item.Value()
  if err != nil {
    return err
  }
  return nil
})
if err != nil {
	log.Fatal(err)
}
fmt.Printf(&amp;quot;The answer is: %s\n&amp;quot;, answer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;get-with-sett&#34;&gt;Get with Sett&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// Sett
answer, err := db.Get(&amp;quot;question&amp;quot;)
if err != nil {
	log.Fatal(err)
}
fmt.Printf(&amp;quot;The answer is: %s\n&amp;quot;, answer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Which version can you remember?&lt;/p&gt;

&lt;p&gt;I should however point out that in BadgerDB, &lt;code&gt;db.View&lt;/code&gt; is a read transaction wrapper.  So, while the above examples both include a single &lt;code&gt;Get&lt;/code&gt; transaction, BadgerDB could accomodate more.&lt;/p&gt;

&lt;p&gt;We could for example retrieve a second key in the same transaction, which would doubtless be more efficient than the two sequential &lt;code&gt;db.View&lt;/code&gt; transactions, required to get two keys when using Sett.&lt;/p&gt;

&lt;p&gt;But, realistically, how often will I want more than one key, selected by specific key? Should I find the need, a small modification to the Sett API could facilitate the return of multples keys in the one &lt;code&gt;GET&lt;/code&gt; call.&lt;/p&gt;

&lt;h2 id=&#34;virtual-tables&#34;&gt;&amp;ldquo;Virtual&amp;rdquo; tables&lt;/h2&gt;

&lt;p&gt;One feature of the Sett API that I find indispensible, is virtual tables.&lt;/p&gt;

&lt;p&gt;Tables are effectively created by adding a prefix to the key which is stored in BadgerDB, hence virtual, since tables are not a feature of BadgerDB.&lt;/p&gt;

&lt;p&gt;With an interface formalised through the Sett API, I&amp;rsquo;ve found it much easier to reason about the data I&amp;rsquo;m working with, by thinking in terms of tables.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example which shows how the use of these virtual tables allows key reuse.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s.Table(&amp;quot;client&amp;quot;).Set(&amp;quot;1234&amp;quot;, &amp;quot;client data&amp;quot;)
// real key is &amp;quot;client1234&amp;quot;
s.Table(&amp;quot;client&amp;quot;).Get(&amp;quot;1234&amp;quot;)
// returns &amp;quot;client data&amp;quot;

s.Table(&amp;quot;supplier&amp;quot;).Set(&amp;quot;1234&amp;quot;, &amp;quot;supplier data&amp;quot;)
// real key is &amp;quot;supplier1234&amp;quot;
s.Table(&amp;quot;supplier&amp;quot;).Get(&amp;quot;1234&amp;quot;)
// returns &amp;quot;supplier data&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Tables also allow us to implement other nice features such as &lt;code&gt;Drop()&lt;/code&gt; which, as you might expect, deletes the virtual table or more accurately, all keys with the table prefix.&lt;/p&gt;

&lt;h2 id=&#34;updates&#34;&gt;Updates&lt;/h2&gt;

&lt;p&gt;BadgerDB also includes a &lt;code&gt;db.Update&lt;/code&gt; transaction wrapper designed to wrap &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Delete&lt;/code&gt; transactions, and it&amp;rsquo;s possible to write or delete multiple items by key.&lt;/p&gt;

&lt;p&gt;This is definitely something I want to do efficiently via Sett, so I implemented batch updates - and the API is not dissimilar to the functionality that used to exist in BadgerDB itself!&lt;/p&gt;

&lt;p&gt;Items are added to the dataset to be stored using &lt;code&gt;Batchcup()&lt;/code&gt;`.&lt;/p&gt;

&lt;p&gt;Large datasets are split into smaller batches of 500 (by default) and each batch of 500 is passed to a goroutine tasked with inserting those 500 keys. We can achieve very high write speed using concurrency and goroutines, though optimum batchsize will depend on size of the dataset and the performance of your hardware.&lt;/p&gt;

&lt;p&gt;Sett splits the dataset into batches for you, in the background, no need to write your own goroutines.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a very simple example which creates a batch of three keys/values, before submitting the batch to BadgerDB for insertion to the &amp;ldquo;client&amp;rdquo; table.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;s.Batchup(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;)
s.Batchup(&amp;quot;hello-again&amp;quot;, &amp;quot;world&amp;quot;)
s.Batchup(&amp;quot;goodbye&amp;quot;, &amp;quot;world&amp;quot;)

s.Table(&amp;quot;client&amp;quot;).SetBatch()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
There&amp;rsquo;s more to Sett, and the README on Github covers it.&lt;/p&gt;

&lt;p&gt;And there&amp;rsquo;s room to improve it. One area of concern is reporting and returning from goroutines which error, and this is something I&amp;rsquo;ll be looking into.&lt;/p&gt;

&lt;p&gt;If you find Sett useful, let me know in the comments. If I&amp;rsquo;ve made any errors please also let me know. I&amp;rsquo;m always learning.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Octogon G-Code File Uploader</title>
      <link>https://slippytrumpet.io/posts/octogon-gcode-file-uploader/</link>
      <pubDate>Tue, 05 Dec 2017 23:05:39 +0000</pubDate>
      
      <guid>https://slippytrumpet.io/posts/octogon-gcode-file-uploader/</guid>
      <description>

&lt;h2 id=&#34;an-automatic-file-upload-utility-for-octoprint&#34;&gt;An automatic file upload utility for OctoPrint&lt;/h2&gt;

&lt;p&gt;Octogon is a simple command line utility which will monitor a single folder on your local file system for the addition/modification of &lt;code&gt;.stl&lt;/code&gt; and &lt;code&gt;.gcode&lt;/code&gt; extension files and automatically copy them to OctoPrint so they appear in your files list.&lt;/p&gt;

&lt;h3 id=&#34;why&#34;&gt;Why?&lt;/h3&gt;

&lt;p&gt;My 3D Printer is right next to me at the moment. But getting files onto it, configuring it, and monitoring it, are jobs that are a bit painful in this wireless age. Everything is done via the LCD control panel and SD card.&lt;/p&gt;

&lt;p&gt;So when I found out about &lt;a href=&#34;http://octoprint.org/&#34;&gt;OctoPrint&lt;/a&gt;, a print server for 3D Printers which runs on a Raspberry Pi, I did it. I bought a Raspberry Pi and installed &lt;a href=&#34;https://octopi.octoprint.org/&#34;&gt;OctoPi&lt;/a&gt;, the prebuilt Raspberry Pi image which includes OctoPrint as well as some other utilities.&lt;/p&gt;

&lt;p&gt;OctoPrint has been a relevation. It offers remote monitoring and control of the 3D printer over LAN - and WAN so long as you configure your router&amp;rsquo;s firewall correctly  - so you can view, monitor, tweak and pause/stop a print job, over a wifi connection.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/olliephillips/octogon&#34;&gt;Octogon&lt;/a&gt; is a simple utility written in Go. It addresses one tiny weakspot in my OctoPrint setup and workflow: the need to physically upload my G-code files via OctoPrint&amp;rsquo;s web interface. Using Octogon, they just appear in the file list and are available for printing.&lt;/p&gt;

&lt;p&gt;With Octogon running. A single folder on my computer is monitored. Any new or modified &lt;code&gt;.gcode&lt;/code&gt;and &lt;code&gt;.stl&lt;/code&gt; files saved into that folder are copied over to OctoPrint automatically using SSH. Save a file locally, and it&amp;rsquo;s almost immediately available on the Raspberry Pi.&lt;/p&gt;

&lt;p&gt;Using it is simple. In most cases the only command line option needed to run the program is the password &lt;code&gt;-p&lt;/code&gt; flag.&lt;/p&gt;

&lt;p&gt;For example, you can start Octogon monitoring the current folder like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ octogon -p sshpasswordtoraspberrypi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;download-octogon&#34;&gt;Download Octogon&lt;/h3&gt;

&lt;p&gt;You can checkout the documentation and source code, as well as download compiled binaries for Linux and Mac, &lt;a href=&#34;https://github.com/olliephillips/octogon&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Unfortunately the Windows build currently doesn&amp;rsquo;t work - the file monitoring is not reliable - and I&amp;rsquo;ll look into this in the near future.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Experiments with Messaging over Ethernet Frames</title>
      <link>https://slippytrumpet.io/posts/experiments-with-message-queuing-over-ethernet-frames/</link>
      <pubDate>Mon, 10 Jul 2017 17:27:33 +0100</pubDate>
      
      <guid>https://slippytrumpet.io/posts/experiments-with-message-queuing-over-ethernet-frames/</guid>
      <description>

&lt;h2 id=&#34;in-his-article-network-protocol-breakdown-ethernet-and-go-https-medium-com-mdlayher-network-protocol-breakdown-ethernet-and-go-de985d726cc1-matt-layher-describes-the-ethernet-protocol-and-introduces-a-couple-of-libraries-written-in-go&#34;&gt;In his article, &lt;a href=&#34;https://medium.com/@mdlayher/network-protocol-breakdown-ethernet-and-go-de985d726cc1&#34;&gt;Network Protocol Breakdown: Ethernet and Go&lt;/a&gt;, Matt Layher describes the Ethernet protocol and introduces a couple of libraries written in Go.&lt;/h2&gt;

&lt;p&gt;I read the article with interest. Application communication, at the Ethernet frame level, a lower level than TCP sockets, was something I&amp;rsquo;d never considered before.&lt;/p&gt;

&lt;p&gt;Of particular interest was the &amp;ldquo;broadcast&amp;rdquo; nature of the communication. In contrast to sockets - though frames can also be addressed to specific devices - frames can be broadcast network-wide, enabling more than one device to listen and use the frame payload.&lt;/p&gt;

&lt;p&gt;I could see some parallels between Ethernet frames and MQTT, a protocol I use frequently in my hardware projects.&lt;/p&gt;

&lt;p&gt;I could also see a few distinct advantages over MQTT. I don&amp;rsquo;t want to go into loads of detail here, but, suffice to say, a cheap, convenient but very insecure approach to using MQTT in what are often just &amp;ldquo;hobby&amp;rdquo; hardware projects, is to bounce traffic off of one of the free remote MQTT brokers. And I have been known to do this ;)&lt;/p&gt;

&lt;h2 id=&#34;so-why-ethernet-frames&#34;&gt;So why Ethernet Frames?&lt;/h2&gt;

&lt;p&gt;Potentially, by using Ethernet frames there would be no requirement for the MQTT broker so that&amp;rsquo;s one less piece of hardware to configure and manage (if you host your own); messages would stay within the local area network, behind the router firewall, so we&amp;rsquo;re secure by default and; we might achieve higher-speed transmissions, since we would not be sending data all the way off to a remote MQTT broker, only to receive it back from that broker on another machine sitting within the same local area network.&lt;/p&gt;

&lt;p&gt;So I set about writing a package on top of Matt&amp;rsquo;s &lt;a href=&#34;https://github.com/mdlayher/ethernet&#34;&gt;Ethernet&lt;/a&gt; and &lt;a href=&#34;https://github.com/mdlayher/raw&#34;&gt;Raw&lt;/a&gt; packages with two objectives in mind:-&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use Ethernet frame messaging to emulate MQTT specifically by providing pub/sub functionality, and;&lt;/li&gt;
&lt;li&gt;Provide an API which would feel familiar to MQTT users and therefore be a relatively simple drop in replacement for a typical MQTT client library.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;methodology&#34;&gt;Methodology&lt;/h2&gt;

&lt;p&gt;The package itself is fairly straightforward - most of the sophisticated stuff is performed by the two packages of Matt&amp;rsquo;s which it imports, but it satisfies both of the objectives mentioned above.&lt;/p&gt;

&lt;p&gt;I took the liberty of naming the package EFMQ (for Ethernet Frames Message Queue), and you can find it &lt;a href=&#34;http://github.com/olliephillips/efmq&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;objective-1-provide-pub-sub-functionality&#34;&gt;Objective 1 - Provide Pub/Sub functionality&lt;/h3&gt;

&lt;p&gt;Pub/Sub is emulated by devices maintaining a list of their own subscriptions and comparing each received message&amp;rsquo;s topic to this list. If topic matches a subscription, the message is put on an unbuffered channel for subsequent processing. Any messages that do not match a subscription are simply discarded.&lt;/p&gt;

&lt;h3 id=&#34;objective-2-provide-an-api-similar-to-mqtt&#34;&gt;Objective 2 - Provide an API similar to MQTT&lt;/h3&gt;

&lt;p&gt;This is best illustrated by a couple of examples.&lt;/p&gt;

&lt;h4 id=&#34;publisher&#34;&gt;Publisher&lt;/h4&gt;

&lt;p&gt;In this contrived example, we&amp;rsquo;re publishing temperature data on the &lt;code&gt;temp&lt;/code&gt; topic every second. &lt;code&gt;wlan0&lt;/code&gt; represents the network interface used by the device, in this case a Raspberry Pi Zero W.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mq, err := efmq.NewEFMQ(&amp;quot;wlan0&amp;quot;) 
if err != nil {
  log.Fatal(err)
}
t := time.NewTicker(1 * time.Second)
for range t.C {
  if err := mq.Publish(&amp;quot;temp&amp;quot;, &amp;quot;20.5&amp;quot;); err != nil {
 	log.Fatalln(err)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h4 id=&#34;subscriber&#34;&gt;Subscriber&lt;/h4&gt;

&lt;p&gt;In this example another device in the same network subscribes to the &lt;code&gt;temp&lt;/code&gt; topic and then listens indefinitely. Any messages which match the subscription are made available on the &lt;code&gt;mq.Message&lt;/code&gt; channel.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mq, err := efmq.NewEFMQ(&amp;quot;wlan0&amp;quot;)
if err != nil {
  log.Fatal(err)
}
mq.Subscribe(&amp;quot;fermenter&amp;quot;)
mq.Listen()
for msg := range mq.Message {
  fmt.Println(&amp;quot;topic:&amp;quot;, msg.Topic)
  fmt.Println(&amp;quot;message:&amp;quot;, msg.Payload)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&#34;performance&#34;&gt;Performance&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re off to a good start by removing the latency transmitting messages via a remote server, and the messaging is direct between two devices, no third device (a local MQTT broker) is needed to relay messages, but as yet I don&amp;rsquo;t have any benchmarks.&lt;/p&gt;

&lt;p&gt;In testing, I&amp;rsquo;ve been running a dummy setup using two Raspberry Pi Zero W devices which have been communicating using EFMQ at an interval of 50ms for over a week with no issues. 50ms means 20 messages per second - more than sufficient for most monitoring and control applications that I&amp;rsquo;m likely to want to build!&lt;/p&gt;

&lt;p&gt;If you give EFMQ a try please let me know how it works for you!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Running your Application as a Service on Pi Zero W</title>
      <link>https://slippytrumpet.io/posts/running-your-app-as-service-on-pi-zero-w/</link>
      <pubDate>Thu, 08 Jun 2017 10:27:15 +0100</pubDate>
      
      <guid>https://slippytrumpet.io/posts/running-your-app-as-service-on-pi-zero-w/</guid>
      <description>

&lt;h1 id=&#34;daemonize-your-application-so-that-it-is-easily-started-stopped-and-resilient-to-crashes&#34;&gt;Daemonize your application so that it is easily started, stopped and resilient to crashes&lt;/h1&gt;

&lt;p&gt;So you&amp;rsquo;ve got your headless Raspberry Pi Zero W all set up and you&amp;rsquo;ve been running applications you&amp;rsquo;ve written for yourself on it? I have, I&amp;rsquo;m using Go with a combination of &lt;a href=&#34;http://embd.kidoman.io/&#34;&gt;Embd&lt;/a&gt; and &lt;a href=&#34;https://periph.io/&#34;&gt;Periph.io&lt;/a&gt; libraries to interact with the hardware on the Pi Zero W itself and external to it.&lt;/p&gt;

&lt;p&gt;But it feels clunky.&lt;/p&gt;

&lt;p&gt;Running &amp;ldquo;headless&amp;rdquo;, with no screen or keyboard, everytime I boot the device I need to SSH to it and kick off the application from the command line.&lt;/p&gt;

&lt;p&gt;One of the apps I have monitors temperature using Onewire and two DS18B20 temperature probes. To have to SSH to the Pi Zero W to run the program that does this, is inconvenient: I need access to a computer with a Terminal, and the Pi Zero W must be accessible over the network via SSH. This won&amp;rsquo;t always be possible.&lt;/p&gt;

&lt;p&gt;Much better would be for me to simply switch on the Pi Zero W and have the program run automatically. Plug and Play.&lt;/p&gt;

&lt;p&gt;We can do this, and more, by running the program as a service, often referred to as &amp;ldquo;daemonizing&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;how-to-daemonize&#34;&gt;How to daemonize?&lt;/h2&gt;

&lt;p&gt;There are &lt;a href=&#34;https://github.com/sevlyar/go-daemon&#34;&gt;Go packages that you can include in your codebase to emulate running as a service&lt;/a&gt;, and whilst I looked into these, this post does not cover them, for there is a simpler way, one which is useful for a program written in any language, not just Go.&lt;/p&gt;

&lt;h3 id=&#34;systemd&#34;&gt;systemd&lt;/h3&gt;

&lt;p&gt;systemd is a service manager for Linux which ships with Raspbian, so it&amp;rsquo;s already installed on your Pi Zero W and allows us to easilly daemonize our application.&lt;/p&gt;

&lt;p&gt;Running the application as a service has several benefits.&lt;/p&gt;

&lt;p&gt;1) We can start, stop and ascertain the status of our application service with simple commands.&lt;/p&gt;

&lt;p&gt;2) systemd will monitor and restart the service in the event our program crashes, so our application is more robust to unforseen errors and bugs.&lt;/p&gt;

&lt;p&gt;3) systemd will start the application for us once our Raspberry Pi W has booted - subject to a few constraints - so we&amp;rsquo;ll no longer need to SSH to the device to kickstart the program.&lt;/p&gt;

&lt;p&gt;Certainly sounds like the way to go!&lt;/p&gt;

&lt;h2 id=&#34;step-1-create-a-systemd-configuration-file-for-your-program&#34;&gt;Step 1 - Create a systemd configuration file for your program&lt;/h2&gt;

&lt;p&gt;systemd needs to know a few things about your application, so you need to give it a configuration file which provides the information required.&lt;/p&gt;

&lt;p&gt;Configuration files have the &lt;code&gt;.service&lt;/code&gt; extension and are stored in this location on your Pi Zero W &lt;code&gt;/etc/systemd/system/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Change directory to &lt;code&gt;/etc/systemd/system&lt;/code&gt; and use &lt;code&gt;sudo nano&lt;/code&gt; to create a new file, with the &lt;code&gt;.service&lt;/code&gt; extension. For example I have &lt;code&gt;tempmon.service&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this file you need to add a few directives. This is my &lt;code&gt;tempmon.service&lt;/code&gt; file, simply amend to suit your application.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## tempmon.service

[Unit]
Description=Temperature Monitor
After=network.target

[Service]
User=root
WorkingDirectory=/home/slippytrumpet
ExecStart=/home/slippytrumpet/tempmon
Restart=on-failure
StartLimitIntervalSec=1800

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
The directives, for the most part, need no explanation, but a couple bear comment.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;After=network.target&lt;/code&gt;, means systemd will run the program once networking is available.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;User=root&lt;/code&gt;, sets the user that the process is to be run as. Since my temperature monitoring application is interfacing with hardware on the Pi Zero W, it needs root privileges.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;StartLimitIntervalSec=1800&lt;/code&gt;, by default the application will be restarted if it crashes, but if it crashes more than the default of 5 times, there will be a pause of 1800 seconds (30 minutes) before systemd attempts to start it again.&lt;/p&gt;

&lt;p&gt;The MAN file for systemd contains all the directives which can be used and &lt;a href=&#34;https://www.freedesktop.org/software/systemd/man/systemd.directives.html&#34;&gt;you can find an online version of that, here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;step-2-enable-the-config-file&#34;&gt;Step 2 - Enable the config file&lt;/h2&gt;

&lt;p&gt;To enable your new config file, so that systemd daemonizes your program, use this command (substituting the name of your file in place of &lt;code&gt;tempmon&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl enable tempmon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
If you edit the file once enabled you will need to reload it with this command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl daemon-reload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Now if you reboot your Pi Zero W, your program will be started by systemd. You can check it&amp;rsquo;s status with the command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo service tempmon status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
And, you can stop and start the program just like any other Linux service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo service tempmon stop
sudo service tempmon start
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Raspberry Pi Zero W &#34;headless&#34; Setup</title>
      <link>https://slippytrumpet.io/posts/raspberry-pi-zero-w-setup/</link>
      <pubDate>Fri, 17 Mar 2017 16:06:50 +0000</pubDate>
      
      <guid>https://slippytrumpet.io/posts/raspberry-pi-zero-w-setup/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;https://thingiverse-production-new.s3.amazonaws.com/renders/ee/4c/d9/f7/3d/326e57726fc5c2070bc5c19417e1814d_preview_featured.jpeg&#34; alt=&#34;alt text&#34; title=&#34;Pi Zero rack/stand&#34; /&gt;
Pictured: My Raspberry Pi Zero W stand/rack. &lt;a href=&#34;https://www.thingiverse.com/thing:2169943&#34;&gt;Get it on Thingiverse&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;an-end-to-end-log-of-the-set-up-process-i-followed-from-my-macbook&#34;&gt;An end-to-end log of the set-up process I followed from my Macbook&lt;/h1&gt;

&lt;h2 id=&#34;what-s-this-all-about&#34;&gt;What&amp;rsquo;s this all about?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Setting up a Raspberry Pi Zero W in a &amp;ldquo;headless&amp;rdquo; configuration, without a keyboard or monitor;&lt;/li&gt;
&lt;li&gt;Configuring access to multiple Wifi access points;&lt;/li&gt;
&lt;li&gt;Securing via passwordless SSH public key only login and Firewall rules configuration;&lt;/li&gt;
&lt;li&gt;Simple command line Terminal access by configuring Hostname/Hosts;&lt;/li&gt;
&lt;li&gt;Creating a custom image, which we can reuse next time we want to configure another Pi Zero W.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To use the information here, you will need a Micro SD card, a full size adapter and an SD card USB drive, and of course, a Rasberry Pi Zero W.&lt;/p&gt;

&lt;h2 id=&#34;why-raspberry-pi-zero-w&#34;&gt;Why Raspberry Pi Zero W?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.raspberrypi.org/products/pi-zero/&#34;&gt;Raspberry Pi Zero W&lt;/a&gt; is a small, powerful and connected (onboard Wifi and Bluetooth) computer.  It&amp;rsquo;s the only Raspberry Pi that&amp;rsquo;s really caught my attention, including the original &amp;lsquo;unconnected&amp;rsquo; Pi Zero.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s small; not much bigger than a NodeMCU &lt;a href=&#34;https://en.wikipedia.org/wiki/ESP8266&#34;&gt;ESP8266&lt;/a&gt; Wifi board, but the Pi Zero W also offers Bluetooth as well as better processor, RAM and storage resources.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s cheap; just launched but only 9GBP. It will give &lt;a href=&#34;https://en.wikipedia.org/wiki/ESP32&#34;&gt;ESP32&lt;/a&gt; something to think on, a board which also has Wifi and Bluetooth, but to buy in a developer friendly form, &amp;lsquo;currently&amp;rsquo; costs a bit more.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s available; in the week it launched I ordered one, and I had it in my hands 2 days later. This makes it a strong contender in the space &lt;a href=&#34;https://getchip.com/&#34;&gt;C.H.I.P&lt;/a&gt; has positioned for itself, which, though arguably a better board with 4GB of onboard storage, is in very short supply.&lt;/p&gt;

&lt;p&gt;It runs Linux; so, much of the stuff I do day-to-day is portable to the Pi Zero W.&lt;/p&gt;

&lt;p&gt;It runs Go; Go compiles for lots of platforms, but STM32 architectures are not supported - the binaries are too big. So I can&amp;rsquo;t use Go on ESP8266 boards, and I have no clue about programming in C. Fortunately for me, Go cross compiles to the Pi Zero W ARM architecture, just fine.&lt;/p&gt;

&lt;h2 id=&#34;going-headless&#34;&gt;Going &amp;ldquo;headless&amp;rdquo;&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;m shooting for a &amp;ldquo;headless&amp;rdquo; setup. No screen and no monitor or other peripherals. I want to access my Pi Zero W like I do servers - over SSH.&lt;/p&gt;

&lt;p&gt;You can connect a monitor and keyboard initially to configure everything, but since I don&amp;rsquo;t have either spare, I&amp;rsquo;m doing it without.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m on a Mac, so this log is Mac focussed. It would be easier on Linux - as you&amp;rsquo;ll see :)&lt;/p&gt;

&lt;h2 id=&#34;we-shoud-start&#34;&gt;We shoud start!&lt;/h2&gt;

&lt;p&gt;What follows is my set-up process, end to end. You should be able to follow it verbatim.&lt;/p&gt;

&lt;p&gt;I didn&amp;rsquo;t know some of this information initially, I used a couple of web resources myself in piecing it together. I&amp;rsquo;ve provided links to these resources where relevant.&lt;/p&gt;

&lt;h3 id=&#34;step-1-download-raspbian-linux-image-and-make-a-bootable-micro-sd-card&#34;&gt;Step 1. Download Raspbian Linux image and make a bootable Micro SD card&lt;/h3&gt;

&lt;p&gt;We need a blank Micro SD card and adapter. And 8GB card seems to be the minimum requirement.&lt;/p&gt;

&lt;p&gt;For a headless configuration we don&amp;rsquo;t need the Pixel GUI/desktop that bundles with the full image, so we can grab the smaller &amp;lsquo;lite&amp;rsquo; image. At time of writing latest was &amp;lsquo;Jessie&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.raspberrypi.org/downloads/raspbian/&#34;&gt;Download it here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Run this command in Terminal, prefix with &lt;code&gt;sudo&lt;/code&gt; if you need to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;diskutil list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Note the lines in the output like these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/dev/disk0 (internal, physical):
/dev/disk1 (internal, virtual):
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Plug the Micro SD card into the adapter and insert it into your SD card slot. Run the same command again. You should see an additional line in the output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/dev/disk0 (internal, physical):
/dev/disk1 (internal, virtual):
/dev/disk2 (internal, physical):
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
The additional line is your Micro SD card.&lt;/p&gt;

&lt;p&gt;Next, we&amp;rsquo;ll unmount it, ready for flashing.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo diskutil unmountdisk /dev/disk2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
In Terminal, change directory to where you have the downloaded Raspbian Jessie Lite image, which for me was Downloads:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ~/Downloads
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Use the &lt;code&gt;dd&lt;/code&gt; command to copy the image to the Micro SD card. Note our use of &lt;code&gt;rdisk2&lt;/code&gt; rather than &lt;code&gt;disk2&lt;/code&gt;. This means &amp;lsquo;raw disk&amp;rsquo; and is supposed to be faster.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dd bs=1m if=2017-03-02-raspbian-jessie-lite.img of=/dev/rdisk2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
You&amp;rsquo;ll loose your Terminal prompt. Wait for the process to complete.&lt;/p&gt;

&lt;p&gt;We now have a bootable Micro SD card.&lt;/p&gt;

&lt;p&gt;We could stick it in the Pi Zero W and boot it right away, but this wouldn&amp;rsquo;t do us much good. With no keyboard or monitor, nor any network connectivity we can&amp;rsquo;t interact with it yet.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EDIT: 05/12/2017.&lt;/strong&gt; There are a couple of useful comments at the bottom of this post which suggest the process I describe next, including the need to create a virtual machine later on, can be simplified in general, and especially for Mac users on later versions of OS X. I haven&amp;rsquo;t had the opportunity to try for myself, but I&amp;rsquo;d encourage you to check that information out also.&lt;/p&gt;

&lt;h3 id=&#34;step-2-access-the-raspbian-linux-image-to-edit-files&#34;&gt;Step 2. Access the Raspbian Linux image to edit files&lt;/h3&gt;

&lt;p&gt;The Raspbian image comprises two sub-partitions; a boot partition which is formatted as FAT32 and the file system partition, of type LINUX.&lt;/p&gt;

&lt;p&gt;If we mount and inspect the SD card in our Mac&amp;rsquo;s Finder, we can only access the BOOT sub-partition. The LINUX filesystem partition is EXT4 format and our Mac Finder can&amp;rsquo;t see/use it.&lt;/p&gt;

&lt;p&gt;We can&amp;rsquo;t mount the sub-partition in Terminal either on Mac, so we need to use Linux.&lt;/p&gt;

&lt;p&gt;A virtual machine is convenient here.&lt;/p&gt;

&lt;p&gt;On Mac, an easy way to create a Linux virtual machine is via &lt;a href=&#34;https://www.vagrantup.com/&#34;&gt;Vagrant&lt;/a&gt; and &lt;a href=&#34;https://www.virtualbox.org/&#34;&gt;VirtualBox&lt;/a&gt;, and &lt;a href=&#34;https://www.jeffgeerling.com/blogs/jeff-geerling/mounting-raspberry-pis-ext4-sd&#34;&gt;I mostly used this guide, by Jeff Geerling&lt;/a&gt; for this part of the process.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.vagrantup.com/downloads.html&#34;&gt;Install Vagrant&lt;/a&gt;, which will install the VirtualBox dependency.&lt;/p&gt;

&lt;p&gt;Grab a recent Ubuntu Linux image using &lt;code&gt;vagrant init&lt;/code&gt; and start the virtual machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant init bento/ubuntu-16.04
vagrant up
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Suspend it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant suspend
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Launch VirtualBox, find the virtual machine and discard the saved state (via the right click option). We need to do this so that we can enable USB.&lt;/p&gt;

&lt;p&gt;Right click again and select &amp;lsquo;Settings&amp;rsquo;. Choose &amp;lsquo;Ports&amp;rsquo; and &amp;lsquo;USB&amp;rsquo; then check &amp;lsquo;Enable USB Controller&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Plug the USB SD flash drive into one of the USB ports. Insert the Micro SD card (with the adapter if required) into the USB SD flash drive.&lt;/p&gt;

&lt;p&gt;Check in Mac Finder that the card has not been mounted. If it has, unmount it.&lt;/p&gt;

&lt;p&gt;Start the virtual machine from within VirtualBox and login as the &lt;code&gt;vagrant&lt;/code&gt; user:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;vagrant login: vagrant
Password: vagrant
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Click the USB option in the virtual machine window and select the USB Mass Storage device, which represents the USB SD flash drive/Micro SD card to give the virtual machine access to this drive.&lt;/p&gt;

&lt;p&gt;If it is not selectable, double check in Finder that it has not been mounted.&lt;/p&gt;

&lt;p&gt;Key the following in the virtual machine&amp;rsquo;s Terminal prompt.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo fdisk -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
This should identify both sub-partitions on the Micro SD card.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Device          Type
/dev/sdb1       Win95 FAT32 (LBA)
/dev/sdb2       Linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Mount the Linux sub-partition and change into this directory.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mount /dev/sdb2 /media/usb
cd /media/usb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
We now have access and can edit files.&lt;/p&gt;

&lt;h3 id=&#34;step-3-edit-files-to-pre-configure-wifi&#34;&gt;Step 3. Edit files to pre-configure Wifi&lt;/h3&gt;

&lt;p&gt;The next step is to configure Wifi, so that when booted our Pi Zero W will connect to a network.&lt;/p&gt;

&lt;p&gt;I typically operate between two Wifi access points, so I have set up both in the configuration below.&lt;/p&gt;

&lt;p&gt;Maybe you only need to connect to one access point? I&amp;rsquo;d still recommend the configuration below, since it&amp;rsquo;s extensible - there if/when you need it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo nano etc/wpa_supplicant/wpa_supplicant.conf 
## Note no preceding &amp;quot;/&amp;quot;. 
## Want to edit file on image not the virtual machine
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
I&amp;rsquo;m working between two access points so configured &lt;code&gt;wpa_supplicant.conf&lt;/code&gt; like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;country=GB
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
    ssid=&amp;quot;SSID_OF_NETWORK_1&amp;quot;
    psk=&amp;quot;password&amp;quot;
    id_str=&amp;quot;home&amp;quot;
}

network={
    ssid=&amp;quot;SSID_OF_NETWORK_2&amp;quot;
    psk=&amp;quot;password&amp;quot;
    id_str=&amp;quot;work&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Key &lt;code&gt;Ctrl+x&lt;/code&gt; to  confirm and save.&lt;/p&gt;

&lt;p&gt;We need to make amendments to &lt;code&gt;etc/network/interfaces&lt;/code&gt; also.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo nano etc/network/interfaces
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
The defaults in here need to be amended for multiple access points and roaming between them.&lt;/p&gt;

&lt;p&gt;Again this is my configuration, but a redundant config for a second unused access point should not hurt you - and you may need it later.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source-directory /etc/network/interfaces.d

auto lo
iface lo inet loopback

iface eth0 inet manual

allow-hotplug wlan0
iface wlan0 inet manual
    wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf

allow-hotplug wlan1
iface wlan1 inet manual
    wpa-roam /etc/wpa_supplicant/wpa_supplicant.conf

iface home inet dhcp
iface work inet dhcp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Save the file.&lt;/p&gt;

&lt;p&gt;Unmount the Micro SD card in the SD card flash drive.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd ../../
sudo umount /media/usb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Next, we need to make a single amend to the first boot partition of the Micro SD card, since by default the SSH service is not enabled on Pi Zero.&lt;/p&gt;

&lt;p&gt;So we&amp;rsquo;ll create an empty file named &lt;code&gt;SSH&lt;/code&gt; with no extension. This is deleted at first boot, but SSH is subsequently enabled.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo mount /dev/sdb1 /media/usb
cd /media/usb
sudo touch SSH
cd ../../
sudo umount /media/usb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Insert the Micro SD card into your Pi Zero W and power it up. If all went well you&amp;rsquo;ll connect to an access point. If you configured a second access point, when you go to your second location you&amp;rsquo;ll automatically connect to that access point too.&lt;/p&gt;

&lt;p&gt;Hopefully, it should be evident how to add a third access point (or more) if needed.&lt;/p&gt;

&lt;h3 id=&#34;step-4-configure-passwordless-login-over-ssh&#34;&gt;Step 4. Configure passwordless login over SSH&lt;/h3&gt;

&lt;p&gt;Now we have networking we can connect to the Pi Zero W itself over SSH.&lt;/p&gt;

&lt;p&gt;You can find the IP address of the Pi Zero W by logging into your router and looking at the list of attached devices.&lt;/p&gt;

&lt;p&gt;Alternatively, many routers with DHCP allocate an IP and expose the Pi Zero on the hostname &lt;code&gt;raspberrypi.local&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In Terminal, let&amp;rsquo;s try connect to it.&lt;/p&gt;

&lt;p&gt;The default user is &lt;code&gt;pi&lt;/code&gt; the default password is &lt;code&gt;raspberry&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pi@raspberrypi.local // or ip address
password: raspberry
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Default passwords are never good. Let&amp;rsquo;s sort, for both the &lt;code&gt;root&lt;/code&gt; and &lt;code&gt;pi&lt;/code&gt; users, by changing them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo passwd root
Enter new UNIX password: verylongpasswdyoucannotsee
passwd: password updated successfully

passwd
(current) UNIX password: raspberry
Enter new UNIX password: verylongpasswdyoucannotsee
passwd: password updated successfully
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Update and upgrade Raspbian, this takes a few minutes to complete. Hit &lt;code&gt;y&lt;/code&gt; in response to any prompts.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get update
sudo apt-get upgrade
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;
Next we&amp;rsquo;re going to set up SSH passwordless login. This is done by transferring our public key from our Mac to a special location on the Pi Zero W.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re a developer, it&amp;rsquo;s very likely you&amp;rsquo;ll have a private/public key pair already on your Mac, but if not, &lt;a href=&#34;https://docs.joyent.com/public-cloud/getting-started/ssh-keys/generating-an-ssh-key-manually/manually-generating-your-ssh-key-in-mac-os-x&#34;&gt;you&amp;rsquo;ll need to create one&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;On your Pi Zero W create the following folder in your home directory.
&lt;br/&gt;
Then set the permissions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mkdir /home/pi/.ssh
chmod 700 /home/pi/.ssh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Create the &lt;code&gt;authorized_keys&lt;/code&gt; file, and copy over your public key. You need to copy the contents of &lt;code&gt;~/.ssh/id_rsa.pub&lt;/code&gt; into this file.
&lt;br/&gt;
Then set the permissions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nano /home/pi/.ssh/authorized_keys
chmod 400 /home/pi/.ssh/authorized_keys
chown -R pi:pi /home/pi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Open a new Terminal window - !! do not close the current window !!&lt;/p&gt;

&lt;p&gt;Attempt to connect.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pi@raspberrypi.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
This time we should log straight in to our Pi Zero W without being prompted for a password.&lt;/p&gt;

&lt;p&gt;Finally, we will increase security by disabling all SSH password logins, the root user login, and restricting use of the SSH service to only the user &lt;code&gt;pi&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo nano /etc/ssh/sshd_config
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Add, or amend, the following lines in this file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;PermitRootLogin no
PasswordAuthentication no
AllowUsers pi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Restart the SSH service with &lt;code&gt;sudo service ssh restart&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;step-5-configure-a-firewall&#34;&gt;Step 5. Configure a Firewall&lt;/h3&gt;

&lt;p&gt;Last step was a bit intense. Step 5 is nice and easy. We&amp;rsquo;re going to install and set up a Firewall, through which we can block port access to our Pi Zero W.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re going to install and use UFW (Uncomplicated Firewall). This application provides a super easy abstraction to iptables, an application which, personally speaking, I&amp;rsquo;ve often struggled with.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo apt-get install ufw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Now we need to set some rules.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll probably use my Pi Zero W as a webserver, maybe also as a client to consume API services, so I need HTTP and HTTPS, so I need to open ports 80 and 443.&lt;/p&gt;

&lt;p&gt;I also use &lt;a href=&#34;https://sendgrid.com/&#34;&gt;Sendgrid&lt;/a&gt; to relay server email, and that works on port 587.&lt;/p&gt;

&lt;p&gt;Obviously I&amp;rsquo;ll be using SSH to login in, and by default that uses port 22.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo ufw default deny incoming
sudo ufw allow 80
sudo ufw allow 443 
sudo ufw allow 587
sudo ufw allow 22
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Now, start UFW then check the configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo ufw enable
sudo ufw status

Status: active

To                         Action      From
--                         ------      ----
22                         ALLOW       Anywhere
80                         ALLOW       Anywhere
443                        ALLOW       Anywhere
587                        ALLOW       Anywhere
22                         ALLOW       Anywhere (v6)
80                         ALLOW       Anywhere (v6)
443                        ALLOW       Anywhere (v6)
587                        ALLOW       Anywhere (v6)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;
We&amp;rsquo;re firewalled. Feels good yes?
&lt;br/&gt;
At this point our setup is fairly robust. I think so anyway.
&lt;br/&gt;
But we can do more to make using Pi Zero W a lovely experience.&lt;/p&gt;

&lt;h3 id=&#34;step-6-hostname-configuration&#34;&gt;Step 6. Hostname configuration&lt;/h3&gt;

&lt;p&gt;I bet you, like me, have more than one Raspberry Pi Zero W - or will have soon!&lt;/p&gt;

&lt;p&gt;They&amp;rsquo;re handy things, and cheap.&lt;/p&gt;

&lt;p&gt;But, if we&amp;rsquo;re going to use more than one Pi Zero W on the same Wifi network, we have a small problem.&lt;/p&gt;

&lt;p&gt;Unless we want to keep identifying them by IP address, which means checking the router&amp;rsquo;s attached device list, we need a way to tell them apart, as, by default, they all have the hostname of &lt;code&gt;raspberrypi&lt;/code&gt;, addressed as &lt;code&gt;raspberrypi.local&lt;/code&gt; over SSH.&lt;/p&gt;

&lt;p&gt;This is not useful. So let&amp;rsquo;s change it - it&amp;rsquo;s simple.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo nano /etc/hostname
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Replace the &lt;code&gt;raspberrypi&lt;/code&gt; value in this file with the name you want. There are restrictions on what &lt;code&gt;hostname&lt;/code&gt; can be, but I name/number mine like this.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pizero1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Confirm and save.&lt;/p&gt;

&lt;p&gt;Next edit this file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo nano /etc/hosts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Change the last line to match the entry you placed in the &lt;code&gt;/etc/hostname&lt;/code&gt; file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;127.0.1.1       pizero1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Repeat for all your pi zero w boards, and each will be separately identifiable and addressable on your Wifi network.&lt;/p&gt;

&lt;p&gt;For example..&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh pi@pizero1.local
ssh pi@pizero2.local
ssh pi@pizero3.local
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
We&amp;rsquo;re done.&lt;/p&gt;

&lt;h3 id=&#34;step-6-creating-an-image-of-your-work&#34;&gt;Step 6. Creating an image of your work&lt;/h3&gt;

&lt;p&gt;We can&amp;rsquo;t go through this long process - as much fun as it was :/ - every time we want to configure a new Raspberry Pi Zero W, so in this final step we&amp;rsquo;re going to create an image file of everything we&amp;rsquo;ve done so far.&lt;/p&gt;

&lt;p&gt;This image will give us a snapshot of the Operating System and File System, exactly as it is now. One that we can use, in place of the default Raspbian image, when we get another Pi Zero W and need an OS for it.&lt;/p&gt;

&lt;p&gt;With an image, our next setup will just comprise of two simple steps!.&lt;/p&gt;

&lt;p&gt;1) We&amp;rsquo;ll just need to copy the image to a new Micro SD card as we did in Step 1, and then;&lt;/p&gt;

&lt;p&gt;2) log in, and change the hostname just like we did in Step 5.&lt;/p&gt;

&lt;p&gt;Everything else including Wifi, SSH passwordless login and Firewall will be preconfigured out-the-box&lt;/p&gt;

&lt;p&gt;To create the image we use the &lt;code&gt;DD&lt;/code&gt; command from the Mac Terminal application. We unmount the Micro SD card first.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo diskutil unmountdisk /dev/disk2
sudo dd bs=1m if=/dev/rdisk2 of=pi/060317.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
This creates the image file &lt;code&gt;060317.img&lt;/code&gt; in the folder &lt;code&gt;pi&lt;/code&gt; relative to the our current working directory.&lt;/p&gt;

&lt;p&gt;To copy this image to a new Micro SD card for use in another Pi Zero W, we use the &lt;code&gt;DD&lt;/code&gt; command again and simply reverse the parameters such that the source is &lt;code&gt;pi/060317.img&lt;/code&gt; and the destination &lt;code&gt;/dev/rdisk2&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo diskutil unmountdisk /dev/disk2
sudo dd bs=1m if=pi/060317.img of=/dev/rdisk2 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
That&amp;rsquo;s it! We&amp;rsquo;re all done!&lt;/p&gt;

&lt;p&gt;Configuring a Raspberry Pi Zero W from this image is now effortless.&lt;/p&gt;

&lt;h3 id=&#34;potential-stumbling-blocks&#34;&gt;Potential stumbling blocks&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve worked back through this process a couple of times now. I&amp;rsquo;ve had a few issues, which I&amp;rsquo;ve listed here as a heads up.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Unmounting. If you get an unexpected error. Double check the Micro SD card is available, unmounted.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SD Cards of same size. Turns out they are not always. So a 32GB image written back, to a new 32GB card might not always fit. I&amp;rsquo;ve seen this with a cheap 32GB Micro SD card&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SD cards of different sizes. Apparently you &lt;a href=&#34;http://raspberrypi.stackexchange.com/questions/1058/is-this-an-ok-way-to-transfer-my-16gb-sd-card-to-an-8gb-sd-card-simple-dd?rq=1&#34;&gt;can write an image taken from a 32GB card back to a 16GB card, or a 16GB to an 8GB&lt;/a&gt;. The data of the pi image is much less than 8GB. You can also do it the other way round, but by default you lose access to the additional space outside the image. Use &lt;code&gt;sudo rasp-config&lt;/code&gt; to expand the root partition to reclaim this space.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Imaging takes a while. Unless you really need lots of space, working with 8GB cards is quick, consistent and cheap!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;SSH known hosts. You might be prompted that an entry exists which doesn&amp;rsquo;t match the new entry if you&amp;rsquo;re SSHing to a new Pi Zero W. Just follow the filepath and delete the line. It will then work fine.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Let&#39;s Encrypt and Go</title>
      <link>https://slippytrumpet.io/posts/letsencrypt-and-go/</link>
      <pubDate>Mon, 31 Oct 2016 18:43:50 +0100</pubDate>
      
      <guid>https://slippytrumpet.io/posts/letsencrypt-and-go/</guid>
      <description>

&lt;h2 id=&#34;recently-i-implemented-tls-using-let-s-encrypt-for-two-go-applications-i-thought-i-d-outline-the-process-i-followed-and-mention-a-couple-of-issues-i-had&#34;&gt;Recently I implemented TLS using Let&amp;rsquo;s Encrypt for two Go applications. I thought I&amp;rsquo;d outline the process I followed and mention a couple of issues I had.&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://letsencrypt.org/&#34;&gt;Let&amp;rsquo;s Encrypt&lt;/a&gt; is a fabulous service. In making TLS freely accessible to the masses it&amp;rsquo;s helping make the Internet a more secure place.&lt;/p&gt;

&lt;p&gt;For Go applications, there&amp;rsquo;s no automatic install and renewal route, the process you follow to obtain a certificate takes you via the &amp;ldquo;&lt;a href=&#34;http://letsencrypt.readthedocs.io/en/latest/using.html#standalone&#34;&gt;standalone&lt;/a&gt;&amp;rdquo; option.&lt;/p&gt;

&lt;p&gt;Alternatively, you can use a helper package such as &lt;a href=&#34;https://github.com/dkumor/acmewrapper&#34;&gt;ACMEWrapper&lt;/a&gt; in your application; add a bit of code and ACMEWrapper automatically handles certificate creation and more importantly renewal, since Let&amp;rsquo;s Encrypt certificates expire every 90 days.&lt;/p&gt;

&lt;p&gt;I didn&amp;rsquo;t use ACMEWrapper. In fact I only learned of this package after my TLS deployments were done. But even without one of these helper packages, the process of certificate creation and renewal via the &amp;ldquo;standalone&amp;rdquo; route is straightforwards:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Install the Let&amp;rsquo;s Encrypt client &amp;ldquo;Certbot&amp;rdquo; on your server;&lt;/li&gt;
&lt;li&gt;Run a single command to generate the certificates for the required domain;&lt;/li&gt;
&lt;li&gt;Either copy, or symlink, the required key and certificate files to your application.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;unbind-all-your-things&#34;&gt;Unbind all your things&lt;/h2&gt;

&lt;p&gt;To create a certificate for a domain, Let&amp;rsquo;s Encrypt needs to validate you control the domain.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re generating the certificates on the server on you which you want to use them, this requires that port 80 and/or 443 are available to Certbot. This means you&amp;rsquo;ll have to unbind anything running on those ports, which typically means you&amp;rsquo;ll have to stop your application(s) for the duration of the certificate creation process.&lt;/p&gt;

&lt;p&gt;Certbot makes you aware if it can&amp;rsquo;t use the ports it needs, so this is a minor obstacle and quickly overcome. I only mention it in case your application already has users - you&amp;rsquo;ll want to consider when best to run Certbot.&lt;/p&gt;

&lt;p&gt;No big deal but my first issue - my application was already live, and had to go offline for about 20 seconds to free those ports for Certbot.&lt;/p&gt;

&lt;h2 id=&#34;i-think-your-ssl-has-expired&#34;&gt;I think your SSL has expired?&lt;/h2&gt;

&lt;p&gt;Certbot &amp;ldquo;standalone&amp;rdquo; creates four files after successfully completing.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cert.pem
chain.pem
fullchain.pem
privkey.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Your go application needs two - but which two?&lt;/p&gt;

&lt;p&gt;You need a private key, so &lt;code&gt;privkey.pem&lt;/code&gt; is an obvious pick. You also need the certificate itself, so &lt;code&gt;cert.pem&lt;/code&gt; is a reasonable choice too.&lt;/p&gt;

&lt;p&gt;But you need to use the less obviously named &lt;code&gt;fullchain.pem&lt;/code&gt; for the certificate in your Go application. This file combines server, root and intermediate certificates into one.&lt;/p&gt;

&lt;p&gt;Choose the more obvious &lt;code&gt;cert.pem&lt;/code&gt; (as I did) and though the certificate may look good to you and many others, you&amp;rsquo;ll get reports from people using some browsers saying your SSL has expired or your TLS is broken, and they can&amp;rsquo;t or won&amp;rsquo;t use your site.&lt;/p&gt;

&lt;p&gt;Hard to debug.&lt;/p&gt;

&lt;p&gt;So why &lt;code&gt;fullchain.pem&lt;/code&gt;? Though my knowledge is limited, broadly it seems to relate to the fact that Let&amp;rsquo;s Encrypt certificates are currently cross signed by Identrust to ensure browser acceptance. Let&amp;rsquo;s Encrypt is not as yet a root authority so needs this, especially to appear trusted in older browsers.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>