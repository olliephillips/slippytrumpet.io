<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>slippytrumpet.io</title>
    <link>https://slippytrumpet.io/tags/systemd/index.xml</link>
    <description>Recent content on slippytrumpet.io</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <atom:link href="https://slippytrumpet.io/tags/systemd/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Running your Application as a Service on Pi Zero W</title>
      <link>https://slippytrumpet.io/posts/running-your-app-as-service-on-pi-zero-w/</link>
      <pubDate>Thu, 08 Jun 2017 10:27:15 +0100</pubDate>
      
      <guid>https://slippytrumpet.io/posts/running-your-app-as-service-on-pi-zero-w/</guid>
      <description>

&lt;h1 id=&#34;daemonize-your-application-so-that-it-is-easily-started-stopped-and-resilient-to-crashes&#34;&gt;Daemonize your application so that it is easily started, stopped and resilient to crashes&lt;/h1&gt;

&lt;p&gt;So you&amp;rsquo;ve got your headless Raspberry Pi Zero W all set up and you&amp;rsquo;ve been running applications you&amp;rsquo;ve written for yourself on it? I have, I&amp;rsquo;m using Go with a combination of &lt;a href=&#34;http://embd.kidoman.io/&#34;&gt;Embd&lt;/a&gt; and &lt;a href=&#34;https://periph.io/&#34;&gt;Periph.io&lt;/a&gt; libraries to interact with the hardware on the Pi Zero W itself and external to it.&lt;/p&gt;

&lt;p&gt;But it feels clunky.&lt;/p&gt;

&lt;p&gt;Running &amp;ldquo;headless&amp;rdquo;, with no screen or keyboard, everytime I boot the device I need to SSH to it and kick off the application from the command line.&lt;/p&gt;

&lt;p&gt;One of the apps I have monitors temperature using Onewire and two DS18B20 temperature probes. To have to SSH to the Pi Zero W to run the program that does this, is inconvenient: I need access to a computer with a Terminal, and the Pi Zero W must be accessible over the network via SSH. This won&amp;rsquo;t always be possible.&lt;/p&gt;

&lt;p&gt;Much better would be for me to simply switch on the Pi Zero W and have the program run automatically. Plug and Play.&lt;/p&gt;

&lt;p&gt;We can do this, and more, by running the program as a service, often referred to as &amp;ldquo;daemonizing&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;how-to-daemonize&#34;&gt;How to daemonize?&lt;/h2&gt;

&lt;p&gt;There are &lt;a href=&#34;https://github.com/sevlyar/go-daemon&#34;&gt;Go packages that you can include in your codebase to emulate running as a service&lt;/a&gt;, and whilst I looked into these, this post does not cover them, for there is a simpler way, one which is useful for a program written in any language, not just Go.&lt;/p&gt;

&lt;h3 id=&#34;systemd&#34;&gt;systemd&lt;/h3&gt;

&lt;p&gt;systemd is a service manager for Linux which ships with Raspbian, so it&amp;rsquo;s already installed on your Pi Zero W and allows us to easilly daemonize our application.&lt;/p&gt;

&lt;p&gt;Running the application as a service has several benefits.&lt;/p&gt;

&lt;p&gt;1) We can start, stop and ascertain the status of our application service with simple commands.&lt;/p&gt;

&lt;p&gt;2) systemd will monitor and restart the service in the event our program crashes, so our application is more robust to unforseen errors and bugs.&lt;/p&gt;

&lt;p&gt;3) systemd will start the application for us once our Raspberry Pi W has booted - subject to a few constraints - so we&amp;rsquo;ll no longer need to SSH to the device to kickstart the program.&lt;/p&gt;

&lt;p&gt;Certainly sounds like the way to go!&lt;/p&gt;

&lt;h2 id=&#34;step-1-create-a-systemd-configuration-file-for-your-program&#34;&gt;Step 1 - Create a systemd configuration file for your program&lt;/h2&gt;

&lt;p&gt;systemd needs to know a few things about your application, so you need to give it a configuration file which provides the information required.&lt;/p&gt;

&lt;p&gt;Configuration files have the &lt;code&gt;.service&lt;/code&gt; extension and are stored in this location on your Pi Zero W &lt;code&gt;/etc/systemd/system/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Change directory to &lt;code&gt;/etc/systemd/system&lt;/code&gt; and use &lt;code&gt;sudo nano&lt;/code&gt; to create a new file, with the &lt;code&gt;.service&lt;/code&gt; extension. For example I have &lt;code&gt;tempmon.service&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this file you need to add a few directives. This is my &lt;code&gt;tempmon.service&lt;/code&gt; file, simply amend to suit your application.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## tempmon.service

[Unit]
Description=Temperature Monitor
After=network.target

[Service]
User=root
WorkingDirectory=/home/slippytrumpet
ExecStart=/home/slippytrumpet/tempmon
Restart=on-failure
StartLimitIntervalSec=1800

[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
The directives, for the most part, need no explanation, but a couple bear comment.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;After=network.target&lt;/code&gt;, means systemd will run the program once networking is available.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;User=root&lt;/code&gt;, sets the user that the process is to be run as. Since my temperature monitoring application is interfacing with hardware on the Pi Zero W, it needs root privileges.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;StartLimitIntervalSec=1800&lt;/code&gt;, by default the application will be restarted if it crashes, but if it crashes more than the default of 5 times, there will be a pause of 1800 seconds (30 minutes) before systemd attempts to start it again.&lt;/p&gt;

&lt;p&gt;The MAN file for systemd contains all the directives which can be used and &lt;a href=&#34;https://www.freedesktop.org/software/systemd/man/systemd.directives.html&#34;&gt;you can find an online version of that, here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;step-2-enable-the-config-file&#34;&gt;Step 2 - Enable the config file&lt;/h2&gt;

&lt;p&gt;To enable your new config file, so that systemd daemonizes your program, use this command (substituting the name of your file in place of &lt;code&gt;tempmon&lt;/code&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl enable tempmon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
If you edit the file once enabled you will need to reload it with this command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo systemctl daemon-reload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
Now if you reboot your Pi Zero W, your program will be started by systemd. You can check it&amp;rsquo;s status with the command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo service tempmon status
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br/&gt;
And, you can stop and start the program just like any other Linux service:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo service tempmon stop
sudo service tempmon start
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>